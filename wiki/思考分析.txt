思考如下
这几天研究了数据，发现停两次车的公交车数据其实是挺少的，主要集中在高峰时间段。
分高峰时间段，预测早上 7:00-9:00,晚17：30-19：00。
高峰期时间段划分依据来源于论文《梁云_答辩DOC_基于多源数据的路况信息完整性模型研究与实现_v10》

以下计算方法都是基于特定信号灯路口特征日划分下的24个时间段分别计算。

数据预处理:
1从历史数据中刷选出具有二次停车行为的公交车数据，停车判断为两次相邻的GPS点距离小于10米（因为数据有些是间隔1秒一次，因此把
2停车判断间距控制在10米）
两次停车行为的每一条数据处理：第一次停车位置记为dA（即到红绿灯的距离），时间戳为tA 和 第二次停车位置记为dB,时间戳为tB。

一次停车和两次停车的距离标志P计算：
从历史数据中，计算第一次停车位置的平均值aA = average(dA)，作为一次停车和两次停车的距离标志P.

第一次停车延误时间修正：
增加： 从历史数据中算出 （tB-tA）的时间间隔平均值，以此作为两次停车第一次停车A的预测延误时间的修正

由于即使公交车位于距离标志P外，也有很大可能不会停两次车。
因此引入是否停车古典概率C, 从历史数据中算出，C=(距离标志P外，停两次车的公交车数据数目)/(距离标志P外，公交车数据总数目)


实际代码实现：
HashMap<lightID+特征日+时间段,数据集>  array 遍历,算出停车位置平均值aA(即为P)和（tB-tA）的时间间隔。


与系统融合问题：
新建每个特征日下每个时间段的P值，时间间隔
路径一致，读出原有数据到内存，判断其距离是否在P外，如果是则加上时间间隔修正。
二次停车概率的计算 分母： 一个bus集合数据的元素减去背离红绿灯（即"E"）的数据的量
                分子： 二次停车的次数

                程序说明：
                StopJudge.Constant 项目文件路径说明

                1 StopJudge.Main  main2()  计算停车行为  根据源数据lightdata生成中间处理结果lightData_mid
                2 Accuracy.Main   main3() 训练4张表和得到resultOfLeast
                3 LightAccuracy.java 利用resultOfLeast 旧数据得到的四张表和新数据生成的midData来计算准确度得到AllDaysAcuracy.csv输出
                4 AllDaysAcuracy.csv 红绿灯号 数据文件个数 准确度
